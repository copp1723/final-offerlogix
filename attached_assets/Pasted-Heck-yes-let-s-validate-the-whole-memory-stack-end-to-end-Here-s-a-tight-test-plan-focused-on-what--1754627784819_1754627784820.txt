Heck yes—let’s validate the whole memory stack end-to-end. Here’s a tight test plan focused on what you just shipped (MemoryMapper, QueryBuilder, RAG prompts, multi-tenant isolation, fallbacks).

# 1) Happy-path smoke (5–10 min)

**Goal:** a campaign chat reply that clearly references prior wins from memory.

1. **Seed minimal memory**

```bash
# Seed past win
curl -sX POST https://api.supermemory.ai/v3/memories \
 -H "Authorization: Bearer $SUPERMEMORY_API_KEY" -H "Content-Type: application/json" \
 -d '{
  "content":"Last spring SUV service push: Tue 10:00 performed best; tire promo CTR +18%.",
  "containerTags":["client:demoA","type:campaign_summary"],
  "metadata":{"campaignId":"past-1","vertical":"automotive"}
}'
```

2. **Start campaign chat** (in your UI) with:

> “We’re planning a spring SUV service push. What timing and angle should we use?”

**Expect:** Chat cites Tue \~10am and tire promo angle; not generic advice.

---

# 2) MemoryMapper checks

**Write normalization + PII redaction**

* Trigger any write (e.g., email send). Inspect what you send to Supermemory:

  * **Email/phone masked** in content & metadata.
  * `containerTags` include `client:{id}` and **hashed email** (e.g., `lead:h_3b2…`), not raw.

**Batching**

* Fire 25 writes quickly (simulate send batch). Ensure:

  * Batches flush (no unbounded queue).
  * Retries on 429/5xx, then **graceful skip** (no user-visible failure).

---

# 3) QueryBuilder behavior

**Timeout & fallback**

```bash
# Force strict, low timeout via your config (e.g., 100ms)
# Then run a memory-augmented chat prompt.
```

**Expect:** request logs show `timeout=true`, your service returns `ragSkipped:true`, and the chat still answers (without memory hints).

**Opinionated helpers**

* Run a targeted search:

```bash
curl -sX POST https://api.supermemory.ai/v3/search \
 -H "Authorization: Bearer $SUPERMEMORY_API_KEY" -H "Content-Type: application/json" \
 -d '{
  "q":"SUV spring timing + tire promo",
  "limit":5,
  "onlyMatchingChunks":true,
  "rewriteQuery":true,
  "containerTags":["client:demoA"]
}'
```

**Expect:** top chunk references your seeded summary.

---

# 4) Three exact RAG prompts

**Campaign chat prompt**

* Ask for a recommended 3-email sequence.
  **Expect:** it cites historical outcomes (“tire promo second email”) not just boilerplate.

**Lead scoring prompt**

* Post a Mailgun **opened** + **clicked** event for a lead, then run scoring.
  **Expect:** engagement factors include real email events; score increases.

**Optimization prompt**

* Request “optimal send window & expected lift.”
  **Expect:** outputs a specific day/hour with confidence and reasoning tied to stored history.

---

# 5) Multi-tenant isolation (no leakage)

1. Seed similar memory for **demoB**.
2. Search with `containerTags:["client:demoA"]`.
   **Expect:** **only** demoA results.
3. Repeat for demoB—no cross-pollination.

---

# 6) Webhook → memory → scoring loop

1. Simulate events:

```bash
curl -sX POST http://localhost:3000/api/webhooks/mailgun/events \
 -H "Content-Type: application/json" \
 -d '{"event":"opened","message-id":"mid-1","recipient":"alex@example.com","timestamp":1720001111}'
curl -sX POST http://localhost:3000/api/webhooks/mailgun/events \
 -H "Content-Type: application/json" \
 -d '{"event":"clicked","message-id":"mid-1","recipient":"alex@example.com","timestamp":1720002222,"url":"https://dealer.example/test-drive"}'
```

2. Re-score that lead.
   **Expect:** higher engagement, factors show “open/click”, and vehicle/intent detection is reflected if present.

---

# 7) Chaos/failure drills

* **No API key:** remove key → writes should **skip with log**, UI unaffected.
* **429s/5xx burst:** simulate via proxy or env flag → MemoryMapper retries then skips; no user impact; batch not stuck.
* **Search returns 0:** prompts degrade gracefully (no hallucinated “history”).

---

# 8) Metrics & alerts (quick sanity)

Track (even console logs are fine for now):

* `memory_write_ms p50/p95`, `memory_search_ms p50/p95`
* `rag_hit_rate` (≥60% on seeded demo is fine)
* `fallback_rate` (≤5% steady state)
* `tenant_leakage` (should be 0)
* `lead_score_delta_after_event` (positive after opens/clicks)

---

# 9) Go/No-Go gates

* ✅ PII never appears in search results
* ✅ Queries honor `containerTags`
* ✅ Chat/Scoring/Optimization cite **specific** prior data when available
* ✅ Platform behavior unchanged with Supermemory disabled

---

Want me to generate a **Postman collection** + a tiny **Jest e2e** (seed → webhook → chat → scoring → asserts)? Say the word and tell me your base URL/env var names, and I’ll spit out ready-to-run files.
